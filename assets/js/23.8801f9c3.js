(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{449:function(e,a,s){"use strict";s.r(a);var t=s(17),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"keep-alive分享"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive分享"}},[e._v("#")]),e._v(" keep-alive分享")]),e._v(" "),s("blockquote",[s("p",[e._v("抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。")])]),e._v(" "),s("h2",{attrs:{id:"特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[e._v("#")]),e._v(" 特性")]),e._v(" "),s("ul",[s("li",[e._v("包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。")]),e._v(" "),s("li",[e._v("当组件在 "),s("keep-alive",[e._v(" 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行，且 activated 和 deactivated 将会在 "),s("keep-alive",[e._v(" 树内的所有嵌套组件中触发。")])],1)],1),e._v(" "),s("li",[e._v("不会在函数式组件中正常工作，因为它们没有缓存实例。")])]),e._v(" "),s("h2",{attrs:{id:"作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[e._v("#")]),e._v(" 作用")]),e._v(" "),s("ul",[s("li",[e._v("主要用于保留组件状态或避免重新渲染。")])]),e._v(" "),s("h2",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),s("ul",[s("li",[e._v("常驻内存影响性能")]),e._v(" "),s("li",[e._v("keep-alive不能缓存多层级路由菜单问题")])]),e._v(" "),s("h2",{attrs:{id:"api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" api")]),e._v(" "),s("ul",[s("li",[e._v("include - 逗号分隔字符串、正则表达式或一个数组。只有名称匹配的组件会被缓存。")]),e._v(" "),s("li",[e._v("exclude - 逗号分隔字符串、正则表达式或一个数组。任何名称匹配的组件都不会被缓存。")]),e._v(" "),s("li",[e._v("max - 数字。最多可以缓存多少组件实例。")])]),e._v(" "),s("h3",{attrs:{id:"举个🌰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#举个🌰"}},[e._v("#")]),e._v(" 举个🌰")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    <keep-alive :include="Home" :exclude="blackList" :max="amount">\n        <component :is="currentComponent"></component>\n    </keep-alive>\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("h2",{attrs:{id:"原理粗解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理粗解"}},[e._v("#")]),e._v(" 原理粗解")]),e._v(" "),s("h3",{attrs:{id:"keep-alive-方法定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-方法定义"}},[e._v("#")]),e._v(" keep-alive 方法定义")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    // src/core/components/keep-alive.js\n    export default {\n      name: 'keep-alive',\n      abstract: true, // 判断当前组件虚拟dom是否渲染成真是dom的关键（Vue在初始化生命周期的时候，为组件实例建立父子关系会根据abstract属性决定是否忽略某个组件）\n\n      props: {\n        include: patternTypes, // 缓存白名单\n        exclude: patternTypes, // 缓存黑名单\n        max: [String, Number] // 缓存的组件实例数量上限\n      },\n\n      created () {\n        this.cache = Object.create(null) // 缓存虚拟dom\n        this.keys = [] // 缓存的虚拟dom的健集合\n      },\n\n      destroyed () {\n        for (const key in this.cache) { // 删除所有的缓存\n          pruneCacheEntry(this.cache, key, this.keys)\n        }\n      },\n\n      mounted () {\n        // 实时监听黑白名单的变动\n        this.$watch('include', val => {\n          pruneCache(this, name => matches(val, name))\n        })\n        this.$watch('exclude', val => {\n          pruneCache(this, name => !matches(val, name))\n        })\n      },\n\n      render () {\n        // 先省略...\n      }\n    }\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br")])]),s("h3",{attrs:{id:"缓存过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存过程"}},[e._v("#")]),e._v(" 缓存过程")]),e._v(" "),s("blockquote",[s("p",[e._v("init -> $mount -> compile -> render -> vnode -> patch -> dom")])]),e._v(" "),s("ol",[s("li",[e._v("keep-alive的渲染是在patch阶段，这是构建组件树（虚拟DOM树），并将VNode转换成真正DOM节点的过程。")]),e._v(" "),s("li",[e._v("在patch阶段，会执行createComponent函数。keep-alive组件作为父组件，它的render函数会先于被包裹组件执行；那么就只执行时解析道keepAlive的值是true，后面的逻辑不再执行；再次访问被包裹组件时，是已经缓存的组件实例会执行insert逻辑，这样就直接把上一次的DOM插入到了父元素中。")]),e._v(" "),s("li",[e._v("一般的组件，每一次加载都会有完整的生命周期，即生命周期里面对应的钩子函数都会被触发，而keep-alive包裹的组件不再进入$mount过程")]),e._v(" "),s("li",[e._v("执行insert逻辑时会调用了activateChildComponent函数递归地去执行所有子组件的activated钩子函数。")])]),e._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.im/post/5cce49036fb9a031eb58a8f9#heading-7",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底揭秘keep-alive原理"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.im/post/5b407c2a6fb9a04fa91bcf0d#heading-5",target:"_blank",rel:"noopener noreferrer"}},[e._v("keep-alive组件级缓存"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);